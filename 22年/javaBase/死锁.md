22/3/4 周五：

参考文档：

https://www.cnblogs.com/xiaoxi/p/8311034.html

死锁问题

在windows cmd 使用

jps -l

jstack "进程号"

![image-20220304220434572](E:\TyporaDoc\22年\javaBase\死锁.assets\image-20220304220434572.png)

![image-20220304154254438](E:\TyporaDoc\22年\javaBase\死锁.assets\image-20220304154254438.png)

A线程拿到了1号锁，等待2号锁，B线程拿到了2号锁，等待1号锁。

1.因为系统资源不足。
2.进程运行推进的顺序不合适。
3.资源分配不当。

##### 死锁产生的原因：

1. 系统资源的竞争，只有对不可剥夺资源的竞争才可能产生死锁
2. 线程推进顺序非法,线程在获取了锁L1的情况，没有释放L1，又去申请锁L2，产生死锁的根本原因

![image-20220304200138556](E:\TyporaDoc\22年\javaBase\死锁.assets\image-20220304200138556.png)

##### 死锁产生的必要条件

1. 互斥条件：在一段时间内某资源仅为一个线程所占有，此时其他线程请求该资源，则请求线程只能等待。

2. 不剥夺条件：只能由获得该资源的进程自己来释放（主动释放）

3. 请求和保持条件：进程已经保持了至少一个资源，但是又提出新的资源请求，而该资源已被其他竞争占有，此时请求线程被阻塞，但对自己获取的资源保持不放

4. 循环等待条件：存在一种进程资源的循环等待链，存在一种处于等待的进程集合{p1,p2... pn},其中pi等待的资源被p(i+1)占有（i=0，1...n-1）,pn等待的资源被p0占有。

   ![image-20220304203556015](E:\TyporaDoc\22年\javaBase\死锁.assets\image-20220304203556015-1646402369993.png)

通俗解释：

场景：甲乙两人面对面同时过独木桥

1. 互斥条件：一个资源每次只能被一个进程使用。独木桥每次只能通过一个人

2. 请求保持条件：一个进程因请求资源而阻塞，对已获得的资源保持不放。乙不退出桥面，甲也不退出桥面

3. 不剥夺条件：进程已获得资源，在未使用完之前，不能强行剥夺。甲不能强制乙退出，乙不能强制甲退出。
4. 循环等待条件：若干线程之间形成一种头尾的循环等待资源的关系。如果甲不退出桥面，乙不能通过，如果乙不退出桥面，甲不能通过。

##### 如何避免死锁

1. 让程序每次至多只能获取一个锁。
2. 考虑清楚锁的顺序，尽量减少嵌在的加锁交互数量
3. 设置等待时间有个上限。synchronized不具备，Lock和tryLock类可以指定超时等待时间（todo）